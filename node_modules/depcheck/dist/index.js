'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = depcheck;

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _walkdir = require('walkdir');

var _walkdir2 = _interopRequireDefault(_walkdir);

var _minimatch = require('minimatch');

var _minimatch2 = _interopRequireDefault(_minimatch);

var _component = require('./component');

var _component2 = _interopRequireDefault(_component);

var _getNodes = require('./utils/get-nodes');

var _getNodes2 = _interopRequireDefault(_getNodes);

var _requirePackageName = require('require-package-name');

var _requirePackageName2 = _interopRequireDefault(_requirePackageName);

var _discoverPropertyDep = require('./utils/discover-property-dep');

var _discoverPropertyDep2 = _interopRequireDefault(_discoverPropertyDep);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function constructComponent(source, name) {
  return source[name].reduce(function (result, current) {
    return _extends(result, _defineProperty({}, current, require(_path2.default.resolve(__dirname, name, current))));
  }, {});
}

function objectValues(object) {
  return Object.keys(object).map(function (key) {
    return object[key];
  });
}

var availableParsers = constructComponent(_component2.default, 'parser');

var availableDetectors = constructComponent(_component2.default, 'detector');

var availableSpecials = constructComponent(_component2.default, 'special');

var defaultOptions = {
  withoutDev: false,
  ignoreBinPackage: false,
  ignoreMatches: [],
  ignoreDirs: ['.git', '.svn', '.hg', '.idea', 'node_modules', 'bower_components'],
  parsers: {
    '*.js': availableParsers.jsx,
    '*.jsx': availableParsers.jsx,
    '*.coffee': availableParsers.coffee,
    '*.litcoffee': availableParsers.coffee,
    '*.coffee.md': availableParsers.coffee
  },
  detectors: [availableDetectors.importDeclaration, availableDetectors.requireCallExpression, availableDetectors.gruntLoadTaskCallExpression],
  specials: objectValues(availableSpecials)
};

function getOrDefault(opt, key) {
  return typeof opt[key] !== 'undefined' ? opt[key] : defaultOptions[key];
}

function unifyParser(parsers) {
  return _extends.apply(undefined, [{}].concat(_toConsumableArray(Object.keys(parsers).map(function (key) {
    return _defineProperty({}, key, parsers[key] instanceof Array ? parsers[key] : [parsers[key]]);
  }))));
}

function safeDetect(detector, node) {
  try {
    return detector(node);
  } catch (error) {
    return [];
  }
}

function minus(array1, array2) {
  return array1.filter(function (item) {
    return array2.indexOf(item) === -1;
  });
}

function intersect(array1, array2) {
  return array1.filter(function (item) {
    return array2.indexOf(item) !== -1;
  });
}

function unique(array, item) {
  return array.indexOf(item) === -1 ? array.concat([item]) : array;
}

function concat(array, item) {
  return array.concat(item);
}

function isStringArray(obj) {
  return obj instanceof Array && obj.every(function (item) {
    return typeof item === 'string';
  });
}

function getDependencies(dir, filename, deps, parser, detectors) {
  var detect = function detect(node) {
    return detectors.map(function (detector) {
      return safeDetect(detector, node);
    }).reduce(concat, []);
  };

  return new Promise(function (resolve, reject) {
    _fs2.default.readFile(filename, 'utf8', function (error, content) {
      if (error) {
        reject(error);
      }

      try {
        resolve(parser(content, filename, deps, dir));
      } catch (syntaxError) {
        reject(syntaxError);
      }
    });
  }).then(function (ast) {
    // when parser returns string array, skip detector step and treat them as dependencies directly.
    if (isStringArray(ast)) {
      return ast;
    }

    var dependencies = (0, _getNodes2.default)(ast).map(detect).reduce(concat, []).reduce(unique, []).map(_requirePackageName2.default);

    var peerDeps = dependencies.map(function (dep) {
      return (0, _discoverPropertyDep2.default)(dep, 'peerDependencies', deps, dir);
    }).reduce(concat, []);

    var optionalDeps = dependencies.map(function (dep) {
      return (0, _discoverPropertyDep2.default)(dep, 'optionalDependencies', deps, dir);
    }).reduce(concat, []);

    return dependencies.concat(peerDeps).concat(optionalDeps);
  });
}

function checkFile(dir, filename, deps, devDeps, parsers, detectors) {
  var _ref2;

  var basename = _path2.default.basename(filename);
  var targets = (_ref2 = []).concat.apply(_ref2, _toConsumableArray(Object.keys(parsers).filter(function (glob) {
    return (0, _minimatch2.default)(basename, glob, { dot: true });
  }).map(function (key) {
    return parsers[key];
  })));

  return targets.map(function (parser) {
    return getDependencies(dir, filename, deps.concat(devDeps), parser, detectors).then(function (used) {
      return {
        dependencies: minus(deps, used),
        devDependencies: minus(devDeps, used)
      };
    }, function (error) {
      return {
        dependencies: deps,
        devDependencies: devDeps,
        invalidFiles: _defineProperty({}, filename, error)
      };
    });
  });
}

function checkDirectory(dir, rootDir, ignoreDirs, deps, devDeps, parsers, detectors) {
  return new Promise(function (resolve) {
    var promises = [];
    var finder = (0, _walkdir2.default)(dir, { 'no_recurse': true });

    finder.on('directory', function (subdir) {
      return ignoreDirs.indexOf(_path2.default.basename(subdir)) === -1 && promises.push(checkDirectory(subdir, rootDir, ignoreDirs, deps, devDeps, parsers, detectors));
    });

    finder.on('file', function (filename) {
      return promises.push.apply(promises, _toConsumableArray(checkFile(rootDir, filename, deps, devDeps, parsers, detectors)));
    });

    finder.on('error', function (dirPath, error) {
      return promises.push(Promise.resolve({
        dependencies: deps,
        devDependencies: devDeps,
        invalidDirs: _defineProperty({}, dirPath, error)
      }));
    });

    finder.on('end', function () {
      return resolve(Promise.all(promises).then(function (results) {
        return results.reduce(function (obj, current) {
          return {
            dependencies: intersect(obj.dependencies, current.dependencies),
            devDependencies: intersect(obj.devDependencies, current.devDependencies),
            invalidFiles: _extends(obj.invalidFiles, current.invalidFiles),
            invalidDirs: _extends(obj.invalidDirs, current.invalidDirs)
          };
        }, {
          dependencies: deps,
          devDependencies: devDeps,
          invalidFiles: {},
          invalidDirs: {}
        });
      }));
    });
  });
}

function isIgnored(ignoreMatches, dependency) {
  return ignoreMatches.some(function (match) {
    return (0, _minimatch2.default)(dependency, match);
  });
}

function hasBin(rootDir, dependency) {
  try {
    var depPkg = require(_path2.default.join(rootDir, 'node_modules', dependency, 'package.json'));
    return depPkg.hasOwnProperty('bin');
  } catch (error) {
    return false;
  }
}

function filterDependencies(rootDir, ignoreBinPackage, ignoreMatches, dependencies) {
  return Object.keys(dependencies).filter(function (dependency) {
    return ignoreBinPackage && hasBin(rootDir, dependency) || isIgnored(ignoreMatches, dependency) ? false : true;
  });
}

function depcheck(rootDir, options, cb) {
  var withoutDev = getOrDefault(options, 'withoutDev');
  var ignoreBinPackage = getOrDefault(options, 'ignoreBinPackage');
  var ignoreMatches = getOrDefault(options, 'ignoreMatches');
  var ignoreDirs = defaultOptions.ignoreDirs.concat(options.ignoreDirs).reduce(unique, []);

  var detectors = getOrDefault(options, 'detectors');
  var parsers = _extends({ '*': getOrDefault(options, 'specials') }, unifyParser(getOrDefault(options, 'parsers')));

  var metadata = options.package || require(_path2.default.join(rootDir, 'package.json'));
  var dependencies = metadata.dependencies || {};
  var devDependencies = metadata.devDependencies || {};
  var deps = filterDependencies(rootDir, ignoreBinPackage, ignoreMatches, dependencies);
  var devDeps = filterDependencies(rootDir, ignoreBinPackage, ignoreMatches, withoutDev ? [] : devDependencies);

  return checkDirectory(rootDir, rootDir, ignoreDirs, deps, devDeps, parsers, detectors).then(cb);
}

depcheck.parser = availableParsers;
depcheck.detector = availableDetectors;
depcheck.special = availableSpecials;
module.exports = exports['default'];